// Document Generation Service
// Template-based document generation with Handlebars
// Part of Rainy Cowork Phase 3 - Milestone 3.2

use handlebars::{Handlebars, RenderError};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use thiserror::Error;

/// Error types for document generation
#[derive(Error, Debug)]
pub enum DocumentError {
    #[error("Template not found: {0}")]
    TemplateNotFound(String),
    #[error("Render error: {0}")]
    RenderError(#[from] RenderError),
    #[error("Invalid context: {0}")]
    InvalidContext(String),
    #[error("Export error: {0}")]
    ExportError(String),
}

/// Document template definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentTemplate {
    /// Unique template identifier
    pub id: String,
    /// Display name
    pub name: String,
    /// Template description
    pub description: String,
    /// Template category
    pub category: TemplateCategory,
    /// Handlebars template content
    pub content: String,
    /// Required context fields
    pub required_fields: Vec<TemplateField>,
}

/// Template categories
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum TemplateCategory {
    Report,
    Meeting,
    Email,
    Note,
    Custom,
}

/// Template field definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateField {
    /// Field name (used in template as {{field_name}})
    pub name: String,
    /// Display label
    pub label: String,
    /// Field type
    pub field_type: FieldType,
    /// Whether field is required
    pub required: bool,
    /// Default value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
}

/// Field types for template context
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum FieldType {
    Text,
    Textarea,
    Date,
    List,
}

/// Generated document metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedDocument {
    /// Document ID
    pub id: String,
    /// Template used
    pub template_id: String,
    /// Generated content (Markdown)
    pub content_markdown: String,
    /// Generation timestamp
    pub generated_at: String,
    /// Word count
    pub word_count: usize,
}

/// Document generation service
pub struct DocumentService {
    handlebars: Handlebars<'static>,
    templates: HashMap<String, DocumentTemplate>,
}

impl Default for DocumentService {
    fn default() -> Self {
        Self::new()
    }
}

impl DocumentService {
    /// Create new DocumentService with built-in templates
    pub fn new() -> Self {
        let mut service = Self {
            handlebars: Handlebars::new(),
            templates: HashMap::new(),
        };

        // Register built-in templates
        service.register_builtin_templates();

        service
    }

    /// Register built-in document templates
    fn register_builtin_templates(&mut self) {
        // Meeting Notes Template
        self.register_template(DocumentTemplate {
            id: "meeting_notes".to_string(),
            name: "Meeting Notes".to_string(),
            description: "Standard meeting notes with agenda and action items".to_string(),
            category: TemplateCategory::Meeting,
            content: r#"# Meeting Notes: {{title}}

**Date:** {{date}}
**Attendees:** {{attendees}}

## Agenda

{{#each agenda}}
- {{this}}
{{/each}}

## Discussion

{{discussion}}

## Action Items

{{#each action_items}}
- [ ] {{this.task}} - **{{this.owner}}** (Due: {{this.due_date}})
{{/each}}

## Next Steps

{{next_steps}}

---
*Generated by Rainy Cowork*
"#
            .to_string(),
            required_fields: vec![
                TemplateField {
                    name: "title".to_string(),
                    label: "Meeting Title".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "date".to_string(),
                    label: "Date".to_string(),
                    field_type: FieldType::Date,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "attendees".to_string(),
                    label: "Attendees".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "discussion".to_string(),
                    label: "Discussion Notes".to_string(),
                    field_type: FieldType::Textarea,
                    required: false,
                    default: None,
                },
            ],
        });

        // Project Report Template
        self.register_template(DocumentTemplate {
            id: "project_report".to_string(),
            name: "Project Report".to_string(),
            description: "Project status report with milestones and risks".to_string(),
            category: TemplateCategory::Report,
            content: r#"# Project Report: {{project_name}}

**Report Date:** {{date}}
**Prepared By:** {{author}}
**Status:** {{status}}

## Executive Summary

{{summary}}

## Milestones

| Milestone | Status | Due Date |
|-----------|--------|----------|
{{#each milestones}}
| {{this.name}} | {{this.status}} | {{this.due_date}} |
{{/each}}

## Key Accomplishments

{{#each accomplishments}}
- {{this}}
{{/each}}

## Risks & Issues

{{#each risks}}
- **{{this.title}}** ({{this.severity}}): {{this.description}}
{{/each}}

## Next Period Goals

{{#each goals}}
- {{this}}
{{/each}}

---
*Generated by Rainy Cowork*
"#
            .to_string(),
            required_fields: vec![
                TemplateField {
                    name: "project_name".to_string(),
                    label: "Project Name".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "date".to_string(),
                    label: "Report Date".to_string(),
                    field_type: FieldType::Date,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "author".to_string(),
                    label: "Author".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "summary".to_string(),
                    label: "Executive Summary".to_string(),
                    field_type: FieldType::Textarea,
                    required: true,
                    default: None,
                },
            ],
        });

        // Email Draft Template
        self.register_template(DocumentTemplate {
            id: "email_draft".to_string(),
            name: "Email Draft".to_string(),
            description: "Professional email template".to_string(),
            category: TemplateCategory::Email,
            content: r#"**To:** {{to}}
**Subject:** {{subject}}

{{greeting}},

{{body}}

{{closing}},
{{signature}}
"#
            .to_string(),
            required_fields: vec![
                TemplateField {
                    name: "to".to_string(),
                    label: "Recipient(s)".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "subject".to_string(),
                    label: "Subject".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "greeting".to_string(),
                    label: "Greeting".to_string(),
                    field_type: FieldType::Text,
                    required: false,
                    default: Some("Hello".to_string()),
                },
                TemplateField {
                    name: "body".to_string(),
                    label: "Email Body".to_string(),
                    field_type: FieldType::Textarea,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "closing".to_string(),
                    label: "Closing".to_string(),
                    field_type: FieldType::Text,
                    required: false,
                    default: Some("Best regards".to_string()),
                },
                TemplateField {
                    name: "signature".to_string(),
                    label: "Signature".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
            ],
        });

        // Quick Note Template
        self.register_template(DocumentTemplate {
            id: "quick_note".to_string(),
            name: "Quick Note".to_string(),
            description: "Simple note with title and content".to_string(),
            category: TemplateCategory::Note,
            content: r#"# {{title}}

*Created: {{date}}*

{{content}}

{{#if tags}}
**Tags:** {{#each tags}}#{{this}} {{/each}}
{{/if}}
"#
            .to_string(),
            required_fields: vec![
                TemplateField {
                    name: "title".to_string(),
                    label: "Title".to_string(),
                    field_type: FieldType::Text,
                    required: true,
                    default: None,
                },
                TemplateField {
                    name: "content".to_string(),
                    label: "Content".to_string(),
                    field_type: FieldType::Textarea,
                    required: true,
                    default: None,
                },
            ],
        });
    }

    /// Register a new template
    pub fn register_template(&mut self, template: DocumentTemplate) {
        let template_id = template.id.clone();

        // Register with Handlebars
        if let Err(e) = self
            .handlebars
            .register_template_string(&template_id, &template.content)
        {
            eprintln!("Failed to register template {}: {}", template_id, e);
            return;
        }

        self.templates.insert(template_id, template);
    }

    /// List all available templates
    pub fn list_templates(&self) -> Vec<&DocumentTemplate> {
        self.templates.values().collect()
    }

    /// Get templates by category
    pub fn get_templates_by_category(&self, category: TemplateCategory) -> Vec<&DocumentTemplate> {
        self.templates
            .values()
            .filter(|t| t.category == category)
            .collect()
    }

    /// Get a specific template
    pub fn get_template(&self, template_id: &str) -> Option<&DocumentTemplate> {
        self.templates.get(template_id)
    }

    /// Generate a document from template
    pub fn generate(
        &self,
        template_id: &str,
        context: &serde_json::Value,
    ) -> Result<GeneratedDocument, DocumentError> {
        // Check template exists
        let template = self
            .templates
            .get(template_id)
            .ok_or_else(|| DocumentError::TemplateNotFound(template_id.to_string()))?;

        // Render template
        let content_markdown = self.handlebars.render(template_id, context)?;

        // Calculate word count
        let word_count = content_markdown.split_whitespace().count();

        // Generate unique ID
        let id = format!("doc_{}", chrono::Utc::now().timestamp_millis());

        Ok(GeneratedDocument {
            id,
            template_id: template_id.to_string(),
            content_markdown,
            generated_at: chrono::Utc::now().to_rfc3339(),
            word_count,
        })
    }

    /// Convert markdown to HTML
    pub fn markdown_to_html(markdown: &str) -> String {
        // Basic markdown to HTML conversion
        // For more robust conversion, consider pulldown-cmark
        let mut html = markdown.to_string();

        // Headers
        for i in (1..=6).rev() {
            let hashes = "#".repeat(i);
            let pattern = format!("\n{} ", hashes);
            let replacement = format!("\n<h{}> ", i);
            html = html.replace(&pattern, &replacement);
            html = html.replace(&format!("<h{}> ", i), &format!("<h{}>\n", i));
        }

        // Bold
        html = html
            .replace("**", "<strong>")
            .replace("</strong></strong>", "</strong>");

        // Italic
        html = html.replace("*", "<em>").replace("</em></em>", "</em>");

        // Line breaks
        html = html.replace("\n\n", "</p><p>");
        html = format!("<p>{}</p>", html);

        html
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_list_templates() {
        let service = DocumentService::new();
        let templates = service.list_templates();
        assert!(!templates.is_empty());
    }

    #[test]
    fn test_generate_quick_note() {
        let service = DocumentService::new();

        let context = json!({
            "title": "Test Note",
            "date": "2026-01-18",
            "content": "This is a test note."
        });

        let result = service.generate("quick_note", &context);
        assert!(result.is_ok());

        let doc = result.unwrap();
        assert!(doc.content_markdown.contains("Test Note"));
        assert!(doc.word_count > 0);
    }

    #[test]
    fn test_generate_meeting_notes() {
        let service = DocumentService::new();

        let context = json!({
            "title": "Sprint Planning",
            "date": "2026-01-18",
            "attendees": "Alice, Bob, Charlie",
            "agenda": ["Review backlog", "Estimate stories", "Plan sprint"],
            "discussion": "Discussed priority items.",
            "action_items": [
                {"task": "Create design doc", "owner": "Alice", "due_date": "2026-01-20"},
                {"task": "Review PR", "owner": "Bob", "due_date": "2026-01-19"}
            ],
            "next_steps": "Follow up next Monday"
        });

        let result = service.generate("meeting_notes", &context);
        assert!(result.is_ok());

        let doc = result.unwrap();
        assert!(doc.content_markdown.contains("Sprint Planning"));
        assert!(doc.content_markdown.contains("Alice, Bob, Charlie"));
    }

    #[test]
    fn test_template_not_found() {
        let service = DocumentService::new();
        let result = service.generate("nonexistent", &json!({}));
        assert!(result.is_err());
    }
}
